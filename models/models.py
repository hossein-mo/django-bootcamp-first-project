import os
import sys
from datetime import datetime, date
from mysql.connector import Error as dbError
from typing import Union, Dict

sys.path.append(os.path.dirname(os.path.dirname(__file__)))
from utils.utils import hash_password
from models.base_models import Column, UserRole, BaseModel
from models.model_exceptions import (
    NotEnoughBalance,
    WrongCredentials,
    DuplicatedEntry,
)


class User(BaseModel):
    name = "user"
    id = Column("id", "INT UNSIGNED", primary_key=True, auto_increment=True)
    username = Column("username", "VARCHAR(255)", unique=True)
    password = Column("password", "CHAR(64)")
    email = Column("email", "VARCHAR(255)", unique=True)
    phone_number = Column("phone_number", "VARCHAR(255)", null=True)
    wallet = Column("wallet", "INT UNSIGNED")
    role = Column(
        "role", f"ENUM({UserRole.get_comma_seperated()})", default=UserRole.USER.value
    )
    birth_date = Column("birth_date", "DATE")
    register_date = Column("register_date", "DATETIME")
    last_login = Column("last_login", "DATETIME")

    def __init__(
        self,
        username: str,
        password: str,
        email: str,
        phone_number: str,
        wallet: int,
        role: Union[str, UserRole],
        birth_date: date,
        register_date: datetime,
        last_login: datetime,
        id: Union[int, None] = None,
    ) -> None:
        """Constructor for user model

        Args:
            username (str): username
            password (str): user password
            email (str): user email
            phone_number (str): user phone_number
            wallet (int): user wallet
            role (Union[str, UserRole]): user role
            birth_date (date): user birth_date
            register_date (datetime): user register_date
            last_login (datetime): user last_login
            id (Union[int, None], optional): user id generated by db when inserting. Defaults to None.
        """
        self.id = id
        self.username = username
        self.password = password
        self.email = email
        self.role = UserRole(role)
        self.birth_date = birth_date
        self.register_date = register_date
        self.last_login = last_login
        self.phone_number = phone_number
        self.wallet = wallet

    def update_last_login(self) -> None:
        """Updated the last login time of the user in database to now"""
        self.last_login = datetime.now()
        self.update({User.last_login: self.last_login})

    @staticmethod
    def autenthicate(username: str, password: str) -> "User":
        """_summary_

        Args:
            username (str): username
            password (str): password

        Raises:
            UserNotExist: if user with input username dosen't exist in database
            WrongCredentials: if input password doesn't match the user password

        Returns:
            User: autenthicated user
        """
        password = hash_password(password)
        user = User.fetch_obj(where=f'{User.username} = "{username}"')
        if not user:
            print("user doesn't exist")
            raise WrongCredentials
        else:
            user = user[0]
            if user.password != password:
                print("wrong password")
                raise WrongCredentials
            return user

    @classmethod
    def create_new(
        cls,
        username: str,
        password: str,
        email: str,
        phone_number: str,
        role: Union[str, UserRole],
        birth_date: Dict[str, int],
    ) -> "User":
        """_summary_

        Args:
            username (str): username
            password (str): user password
            email (str): user email
            phone_number (str): user phone_number
            role (Union[str, UserRole]): user role
            birth_date (date): user birth_date

        Returns:
            User: return a User instance with specified inputs with \
                wallet balance set to zero and hashed password.
        """
        password = hash_password(password)
        rightnow = datetime.now()
        user = cls(
            username,
            password,
            email,
            phone_number,
            0,
            role,
            birth_date,
            rightnow,
            rightnow,
        )
        try:
            user.insert()
        except DuplicatedEntry as err:
            print("entered username or email is taken")
            raise
        else:
            return user


class BankAccount(BaseModel):
    name = "bank_account"
    id = Column("id", "INT UNSIGNED", primary_key=True, auto_increment=True)
    card_number = Column("card_number", "CHAR(16)")
    cvv2 = Column("cvv2", "varchar(255)")
    password = Column("password", "CHAR(64)")
    balance = Column("balance", "INT UNSIGNED")
    user_id = Column(
        "user_id", "INT UNSIGNED", foreign_key=User.id.name, reference=User.name
    )

    def __init__(
        self,
        card_number: str,
        cvv2: str,
        password: str,
        balance: int,
        user_id: int,
        id: Union[None, int] = None,
    ) -> None:
        """Constructor for bank account model

        Args:
            card_number (str): card number
            cvv2 (str): cvv2
            password (str): card password
            balance (int): account balance
            user_id (int): account owner user id
            id (Union[None, str], optional): bank account id. Defaults to None.
        """
        self.id = id
        self.card_number = card_number
        self.cvv2 = cvv2
        self.password = password
        self.balance = balance
        self.user_id = user_id

    def delete(self):
        self.delete()

    def update(self):
        self.update(
            {
                BankAccount.card_number: self.card_number,
                BankAccount.cvv2: self.cvv2,
                BankAccount.password: self.password,
            }
        )

    @staticmethod
    def add_new_account(account: "BankAccount"):
        account.insert()

    def deposit(self, amount: int) -> None:
        """Add amount to user's balance and update database.

        Args:
            amount (int): amount to deposit
        """
        self.balance += amount
        self.update({BankAccount.balance: self.balance})

    def withdraw(self, amount: int) -> None:
        self.balance -= amount
        self.update({BankAccount.balance: self.balance})

    def transfer(self, other: "BankAccount", amount: int):
        """Transfer amount from instance balance to destination instance balance.

        Args:
            other (BankAccount): destination account
            amount (int): amount of transfer

        Raises:
            NotEnoughBalance: if amount > origin account balance.
        """
        if amount > self.balance:
            raise NotEnoughBalance
        else:
            self.balance -= amount
            other.balance += amount
            query1 = self.update_query({BankAccount.balance: self.balance})
            query2 = other.update_query({BankAccount.balance: other.balance})
            try:
                self.db_obj.transaction([query1, query2])
            except dbError as err:
                print(f'Error while updating rows in "{self.name}".')
                print(f"Error description: {err}")

    @classmethod
    def create_new(
        cls, card_number: str, cvv2: str, password: str, balance: int, user_id: int
    ) -> "BankAccount":
        """_summary_

        Args:
            card_number (str): card number
            cvv2 (str): cvv2
            password (str): card password
            balance (int): account balance
            user_id (int): account owner user id

        Returns:
            BankAccount: return an instance of BankAccount with hashed password
        """
        password = hash_password(password)
        return cls(card_number, cvv2, password, balance, user_id)


class Subscription(BaseModel):
    name = "subscription"
    id = Column("id", "INT UNSIGNED", primary_key=True, auto_increment=True)
    s_name = Column("name", "VARCHAR(255)")
    discount = Column("discount", "SMALLINT UNSIGNED")
    duration = Column("duration", "SMALLINT UNSIGNED")
    order_number = Column("order_number", "VARCHAR(255)", null=True)

    def __init__(
        self, name, discount, duration=30, order_number=0, id: Union[int, None] = None
    ):
        self.id = id
        self.name = name
        self.discount = discount
        self.duration = duration
        self.order_number = order_number

    def set_new_subscription(self):
        self.insert()

    def edit_subscription(self):
        self.update(
            {
                Subscription.s_name: self.name,
                Subscription.discount: self.discount,
                Subscription.duration: self.duration,
                Subscription.order_number: self.order_number,
            }
        )

    def delete_subscription(self):
        self.delete()


class Movie(BaseModel):
    name = "movie"
    id = Column("id", "INT UNSIGNED", primary_key=True, auto_increment=True)
    m_name = Column("name", "VARCHAR(255)")
    duration = Column("duration", "TIME")
    age_rating = Column("age_rating", "SMALLINT UNSIGNED")
    screening_number = Column("screening_number", "SMALLINT UNSIGNED")

    def __init__(
        self,
        name: str,
        duration: int,
        age_rating: int,
        screening_number: int,
        id: Union[int, None] = None,
    ) -> None:
        self.id = id
        self.name = name
        self.duration = duration
        self.age_rating = age_rating
        self.screening_number = screening_number

    def add_movie(self):
        self.insert()

    def edit_movie(self):
        self.update(
            {
                Movie.m_name: self.name,
                Movie.duration: self.duration,
                Movie.age_rating: self.age_rating,
                Movie.screening_number: self.screening_number,
            }
        )

    def delete_movie(self):
        self.delete()


class Comment(BaseModel):
    name = "comment"
    id = Column("id", "INT UNSIGNED", primary_key=True, auto_increment=True)
    user_id = Column(
        "user_id", "INT UNSIGNED", foreign_key=User.id.name, reference=User.name
    )
    movie_id = Column(
        "movie_id", "INT UNSIGNED", foreign_key=Movie.id.name, reference=Movie.name
    )
    parent_id = Column("parent_id", "INT UNSIGNED", foreign_key=id.name, reference=name)
    text = Column("text", "TEXT")
    created_at = Column("created_at", "DATE")

    def __init__(
        self,
        user_id,
        movie_id,
        parent_id,
        text,
        created_at=datetime.now(),
        id: Union[int, None] = None,
    ):
        self.id = id
        self.user_id = user_id
        self.movie_id = movie_id
        self.parent_id = parent_id
        self.text = text
        self.created_at = created_at
        self.replies = []

    @staticmethod
    def comment(user_id, movie_id, parent_id, text) -> None:
        Comment(None, user_id, movie_id, parent_id, text).insert()

    @staticmethod
    def get_comments(movie_id) -> list["Comment"]:
        result = []
        comments = Comment.fetch_obj(f"{Comment.movie_id} = {movie_id}")
        for i in range(len(comments)):
            if comments[i].parent_id == 0:
                result.append(comments[i])
            for j in range(i + 1, len(comments)):
                if comments[j].parent_id == comments[i].id:
                    comments[i].replies.append(comments[j])
        return result


class UserSubscription(BaseModel):
    name = "user_subscription"
    id = Column("id", "INT UNSIGNED", primary_key=True, auto_increment=True)
    user_id = Column(
        "user_id", "INT UNSIGNED", foreign_key=User.id.name, reference=User.name
    )
    subscription_id = Column(
        "subscription_id",
        "INT UNSIGNED",
        foreign_key=Subscription.id.name,
        reference=Subscription.name,
    )
    buy_date = Column("buy_date", "DATETIME")
    expire_date = Column("expire_date", "DATETIME")

    @staticmethod
    def set_user_subscription(user, subscription):
        queries = []
        duration = Subscription.fetch(
            select=f"{Subscription.duration.name}",
            where=f"{Subscription.id.name}={subscription.id}",
        )
        duration - duration[0][Subscription.duration.name]
        price = Subscription.fetch(
            select=f"{Subscription.price.name}",
            where=f"{Subscription.id.name}={subscription.id}",
        )
        price = price[0][Subscription.price.name]
        if user.subscription is not None:
            queries.append(
                f"UPDATE {UserSubscription.name} SET {UserSubscription.expire_date.name} = now() WHERE \
                               {UserSubscription.id.name} = (SELECT {UserSubscription.id.name} from {UserSubscription.name} WHERE \
                                    {UserSubscription.user_id.name} = {user.id} AND {UserSubscription.expire_date.name}>now())"
            )

        queries.append(
            f"UPDATE {User.name} SET {User.wallet.name}={User.wallet.name} - {price} WHERE {User.id.name} = {user.id}"
        )
        queries.append(
            f"INSERT INTO {UserSubscription.name} VALUES ({user.id}, {subscription.id}, NOW(), DATE_ADD(NOW(), INTERVAL {duration} DAY))"
        )

        try:
            UserSubscription.db_obj.transaction(queries)
        except dbError as err:
            # print(f'Error while updating rows in "{self.name}".')
            print(f"Error description: {err}")
